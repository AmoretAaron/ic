initSidebarItems({"constant":[["METRICS","Various metrics observed by this canister, e.g. message latency distribution."],["NETWORK_TOPOLOGY","The configuration of the subnets that should be specified in the init argument on canister install. A `Vec` of subnets, each a `Vec` of canister IDs."],["PAYLOAD_SIZE","Pad requests AND responses to this size (in bytes) if smaller."],["PER_SUBNET_RATE","Number of requests to send to each subnet (other than ours) every round."],["RNG","The pseudo-random number generator we use to pick the next canister to talk to. It doesn't need to be cryptographically secure, we just want it to be simple and fast. The default values for state and stream parameters come from the official documentation: https://rust-random.github.io/rand/rand_pcg/struct.Lcg64Xsh32.html"],["RUNNING","Whether this canister is generating traffic."],["STATE","State of the messaging that we use to check invariants (e.g., sequence numbers)."]],"fn":[["candid_encode_padded","Encodes `t` as Candid, padded to `PAYLOAD_SIZE`."],["candid_reply","Calls \"msg_reply\" with reply being argument encoded as Candid."],["fanout","An internal endpoint that sends a messages to a random canister on each of the remote subnets. This endpoint is repeatedly triggered from the \"start\" call."],["handle_request","Endpoint that handles requests from canisters located on remote subnets."],["is_running","Returns true if this canister should continue generating traffic."],["log","Appends a message to the log, ensuring log size stays below 2000 bytes."],["main",""],["metrics","Query call that serializes metrics as a candid message."],["on_reject","Callback for handling reject responses from \"handle_request\"."],["on_reply","Callback for handling replies from \"handle_request\"."],["schedule_fanout","Enqueues a `fanout()` \"loopback\" call for next round."],["start","Initializes network topology and instructs this canister to start sending requests to other canisters."],["stop","Stops traffic."],["time_nanos","Returns system time in nanoseconds."]],"struct":[["MessagingState","State of the XNet messaging."],["Reply","A `Reply` to the `Request` message, sent from the \"handle_request\" method."],["Request","Request sent by the \"fanout\" method."]]});