initSidebarItems({"enum":[["CanisterIdBlobParseError","Represents an error that can occur when parsing a blob into a [`CanisterId`]."],["CanisterIdError","Represents an error that can occur when constructing a [`CanisterId`] from a [`PrincipalId`]."],["CanisterStatusType","Indicates whether the canister is running, stopping, or stopped."],["CanonicalPartialStateTag",""],["CanonicalStateTag",""],["InstallCodeContextError","Errors that can occur when converting from (sender, [`InstallCodeArgs`]) to an [`InstallCodeContext`]."],["PrincipalIdBlobParseError","Represents an error that can occur when parsing a blob into a [`PrincipalId`]."],["PrincipalIdParseError","Represents an error that can occur when parsing a string into a [`PrincipalId`]."]],"fn":[["freeze_threshold_cycles","Figure out how many cycles a canister should have so that it can support the given amount of storage for the given amount of time, given the storage fee."],["node_id_into_protobuf","Converts a NodeId into its protobuf definition.  Normally, we would use `impl From<NodeId> for pb::NodeId` here however we cannot as both `Id` and `pb::NodeId` are defined in other crates."],["node_id_try_from_protobuf","From its protobuf definition convert to a NodeId.  Normally, we would use `impl TryFrom<pb::NodeId> for NodeId` here however we cannot as both `Id` and `pb::NodeId` are defined in other crates."],["subnet_id_into_protobuf","Converts a SubnetId into its protobuf definition.  Normally, we would use `impl From<SubnetId> for pb::SubnetId` here however we cannot as both `Id` and `pb::SubnetId` are defined in other crates."],["subnet_id_try_from_protobuf","From its protobuf definition convert to a SubnetId.  Normally, we would use `impl TryFrom<pb::SubnetId> for SubnetId` here however we cannot as both `Id` and `pb::SubnetId` are defined in other crates."],["user_id_into_protobuf","Converts a UserId into its protobuf definition.  Normally, we would use `impl From<UserId> for pb::UserId` here however we cannot as both `Id` and `pb::UserId` are defined in other crates."],["user_id_try_from_protobuf","From its protobuf definition convert to a UserId.  Normally, we would use `impl TryFrom<pb::UserId> for UserId` here however we cannot as both `Id` and `pb::UserId` are defined in other crates."]],"mod":[["artifact","Artifact related types."],["batch","Contains Batch, Payload, and specific Payload types that are passed between Consensus and Message Routing."],["chunkable","[`Chunkable`] Artifact Trait."],["consensus","Defines types used internally by consensus components."],["crypto","Defines crypto component types."],["filetree_sync","File tree sync artifact."],["funds","Defines types that are useful when handling funds on the IC."],["ic00","Data types used for encoding/decoding the Candid payloads of ic:00."],["ingress","Ingress types."],["malicious_behaviour","Defines [`MaliciousBehaviour`] that allows to control malicious flags."],["malicious_flags","Defines flags that can change a network's behavior."],["messages","Types related to various messages that the Internet Computer handles."],["methods","This module contains a collection of types and structs that define the various types of methods in the IC."],["nominal_cycles","Cycles struct to be used for metrics collection."],["p2p","Defines types used by the P2P component."],["registry","Types for working with the registry."],["replica_config","Defines the [`ReplicaConfig`]."],["replica_version","ReplicaVersion can be converted to/from string representation."],["state_sync","State sync types."],["time","Defines the [`Time`] type used by the Internet Computer."],["transport","Transport layer public types."],["user_error","User-facing error types."],["xnet","Types used by the Xnet component."]],"struct":[["AccumulatedPriority","`AccumulatedPriority` is a part of the SchedulerState. It is the value by which we prioritize canisters for execution. It is reset to 0 in the round where a canister is scheduled and incremented by the canister allocation in each round where the canister is not scheduled."],["CanisterId","A type representing a canister's [`PrincipalId`]."],["ComputeAllocation","`ComputeAllocation` is a percent between 0 and 100 attached to a canister or equivalently a rational number A/100. Having an `ComputeAllocation` of A/100 guarantees that the canister will get a full round at least A out of 100 execution rounds."],["ExecutionRoundTag",""],["HeightTag",""],["IDkgId","The ID for interactive DKG."],["InstallCodeContext",""],["InvalidComputeAllocationError","The error that occurs when an end-user specifies an invalid [`ComputeAllocation`]."],["InvalidMemoryAllocationError","The error that occurs when an end-user specifies an invalid [`MemoryAllocation`]."],["InvalidQueryAllocationError","The error returned when an invalid [`QueryAllocation`] is specified by the end-user."],["MemoryAllocation","`MemoryAllocation` is a number of bytes between 0 and 2^48 inclusively that represents the memory allocation requested by a user during a canister installation/upgrade."],["NodeTag",""],["NumInstructionsTag",""],["PrincipalId","The type representing principals as described in the interface spec."],["QueryAllocation","Type to track how much budget the IC can spend on executing queries on canisters.  See `execution_environment/rs/query_handler.rs:Charging for queries` for more details."],["QueueIndexTag",""],["RandomnessTag",""],["UserTag",""]],"trait":[["CountBytes","Allow an object to report its own byte size. It is only meant to be an estimate, and not an exact measure of its heap usage or length of serialized bytes."]],"type":[["CryptoHashOfPartialState","A cryptographic hash of the part of the canonical replicated state at some height required for certification (cross-net streams, etc.)."],["CryptoHashOfState","A cryptographic hash of a full canonical replicated state at some height."],["ExecutionRound","The id of an execution round in the scheduler."],["Height","The block height."],["NodeId","A type representing a node's [`PrincipalId`]."],["NodeIndex","The index of a node."],["NumBytes","This type models a non-negative number of bytes."],["NumInstructions","Represents an amount of weighted instructions that can be used as the execution cutoff point for messages. This amount can be used to charge the respective amount of `Cycles` on a canister's balance for message execution."],["NumberOfNodes","A non-negative amount of nodes, typically used in DKG."],["QueueIndex","Index into a queue; used in the context of `InputQueue` / `OutputQueue` to define message order."],["Randomness","Randomness produced by Consensus which is used in the deterministic state machine (Message Routing and Execution Environment)."],["RegistryVersion","A type representing the registry's version."],["SubnetId","A type representing a subnet's [`PrincipalId`]."],["UserId","An end-user's [`PrincipalId`]."]]});