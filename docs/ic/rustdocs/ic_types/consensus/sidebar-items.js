initSidebarItems({"enum":[["BlockPayload","Block payload is either DKG summary or (BatchPayload, DKG Dealings)."],["Committee","Indicates one of the consensus committees that are responsible for creating signature shares on various types of artifacts"],["ConsensusMessage","The enum encompassing all of the consensus artifacts exchanged between replicas."],["ConsensusMessageAttribute","ConsensusMessageAttribute has the same variants as [ConsensusMessage], but contains only the attributes for each variant. The attributes are the values that are used in the p2p layer to determine whether an artifact is interesting to a replica before fetching the full artifact."],["ConsensusMessageHash","ConsensusMessageHash has the same variants as [ConsensusMessage], but contains only a hash instead of the full message in each variant."]],"fn":[["get_committee_size","Compute the size of the committee given the total amount of nodes on the subnet"],["get_faults_tolerated","Returns the upper limit of faulty participants for `n` participants."]],"mod":[["catchup","Defines types that allow outdated replicas to catch up to the latest state."],["certification","Defines types used for certification."],["dkg","Defines types used for distributed key generation."],["hashed","An object that is hashable can be bundled together with its hash, which becomes a `Hashed<H, V>` object parameterized by the actual hash type `H` and value type `V`. There are a number of benefits of doing this:"],["thunk","A `Thunk<T>` represents delayed initialization of a value of type `T`. That is, an initialization function of type `FnOnce() -> T` can be used to create a `Thunk<T>` object, and only called once when the thunk is evaluated. Evaluating the same thunk more than once will return the same value as its first evaluation, but will not result in calling the initialization function more than once."]],"struct":[["BasicSignature","BasicSignature captures basic signature on a value and the identity of the replica that signed it"],["Block","Block is the type that is used to create blocks out of which we build a block chain"],["FinalizationContent","FinalizationContent holds the values that are signed in a finalization"],["MultiSignature","MultiSignature captures a cryptographic multi-signature, which is one message signed by multiple signers"],["MultiSignatureShare","MultiSignatureShare is a signature from one replica. Multiple shares can be aggregated into a MultiSignature."],["NotarizationContent","NotarizationContent holds the values that are signed in a notarization"],["Payload","A lazily loaded `BlockPayload` that is also internally shared via an `Arc` pointer so that it is cheap to clone."],["RandomBeaconContent","RandomBeaconContent holds the content that is signed in the random beacon, which is the previous random beacon, the height, and the replica version used to create the random beacon."],["RandomTapeContent","RandomTapeContent holds the content that is signed in the random tape, which is the height and the replica version used to create the random tape."],["Rank","Rank is used to indicate the priority of a block maker, where 0 indicates the highest priority."],["ThresholdSignature","ThresholdSignature captures a threshold signature on a value and the DKG id of the threshold key material used to sign"],["ThresholdSignatureShare","ThresholdSignatureShare captures a share of a threshold signature on a value and the identity of the replica that signed"]],"trait":[["ContentEq","Useful to compare equality by content, for example Signed<C,S> can be compared by equality on C."],["HasBlockHash","Abstract messages with block hash"],["HasCommittee","Abstract messages with committee attribute"],["HasHeight","Abstract messages with height attribute"],["HasRank","Abstract messages with rank attribute"],["HasVersion","Abstract messages with version attribute"]],"type":[["BasicSigned","BasicSigned captures a value of type T and a BasicSignature on it"],["BlockProposal","A BlockProposal is a HashedBlock that is signed by the block maker."],["Finalization","A finalization is a multi-signature on a FinalizationContent. A finalization proves that the block identified by the block hash in the finalization content (and the block chain it implies) is agreed upon."],["FinalizationShare","A finalization share is a multi-signature share on a finalization content. If sufficiently many replicas create finalization shares, the shares can be aggregated into a full finalization."],["HashedBlock","HashedBlock contains a Block together with its hash"],["HashedRandomBeacon","HashedRandomBeacon holds a RandomBeacon and its hash"],["Notarization","A notarization is a multi-signature on a NotarizationContent"],["NotarizationShare","A notarization share is a multi-signature share on a notarization content. If sufficiently many replicas create notarization shares, the shares can be aggregated into a full notarization."],["RandomBeacon","A RandomBeacon is a RandomBeaconContent signed using a threshold signature. The RandomBeacon provides pseudo-randomness to the consensus protocol that is used to assign ranks to block makers and determine which replicas are notaries."],["RandomBeaconShare","RandomBeaconShare is a threshold signature share on a RandomBeaconContent. If sufficiently many replicas create random beacon shares, the shares can be aggregated into a RandomBeacon."],["RandomTape","A RandomTape is a RandomTapeContent signed using a threshold signature. The RandomTape provides pseudo-randomness for executing the messages ordered by consensus."],["RandomTapeShare","RandomTapeShare is a threshold signature share on a RandomTapeContent. If sufficiently many replicas create random tape shares, the shares can be aggregated into a RandomTape."],["Threshold","Threshold indicates how many replicas of a committee need to create a signature share in order to create a signature on behalf of the committee"]]});