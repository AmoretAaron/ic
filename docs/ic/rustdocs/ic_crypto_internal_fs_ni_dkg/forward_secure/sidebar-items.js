initSidebarItems({"constant":[["CHUNK_BYTES","The size in bytes of a chunk"],["CHUNK_MAX","The maximum range of a chunk"],["CHUNK_MIN","The minimum range of a chunk"],["CHUNK_SIZE","The maximum value of a chunk"],["LAMBDA_T","Constant which controls the upper limit of epochs"],["MESSAGE_BYTES","The ciphertext is an element of Fr which is 256-bits"],["NUM_CHUNKS","NUM_CHUNKS is simply the number of chunks needed to hold a message (element of Fr)"]],"enum":[["Bit","Type for a single bit"],["DecErr","Error while decrypting"]],"fn":[["baby_giant","Solves discrete log problem with baby-step giant-step."],["dec_chunks","Decrypt the i-th group of chunks."],["dec_single","The `Dec` function of Section 7.2."],["enc_chunks","Encrypt chunks. Returns ciphertext as well as the random spec_r's and s's chosen, for later use in NIZK proofs."],["enc_single","The `Enc` function of section 7.2."],["epoch_from_tau_vec","Converts an epoch prefix to an epoch by filling in remaining bits with zeros."],["kgen","Generates a (public key, secret key) pair for of forward-secure public-key encryption scheme."],["mk_sys_params","Return NI-DKG system parameters"],["negative_safe_new_int","Create a BIG from an isize"],["node_gen","Generates the specified child of a given BTE node. Only used by slow_derive(), which has been superseded by fast_derive(). We keep it around as documentation. Hopefully it makes fast_derive() easier to understand."],["solve_cheater_log","Brute-forces a discrete log for a malicious DKG participant whose NIZK chunking proof checks out."],["tau_from_epoch","Generates tau (a vector of bits) from an epoch."],["verify_ciphertext_integrity","Verify ciphertext integrity"]],"struct":[["BTENode","A node of a Binary Tree Encryption scheme."],["CRSZ","Forward secure ciphertexts"],["PublicKeyWithPop","A public key and its associated proof of possession"],["SecretKey","A forward-secure secret key is a list of BTE nodes."],["SingleCiphertext","A forward secure ciphertext"],["SysParam","NI-DKG system parameters"],["ToxicWaste","Randomness needed for NIZK proofs."],["ZeroizedBIG","A BIG that cann be zeroized"]]});