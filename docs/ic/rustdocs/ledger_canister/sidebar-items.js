initSidebarItems({"constant":[["HASH_LENGTH",""]],"enum":[["CyclesResponse",""],["Transfer","An operation which modifies account balances"]],"fn":[["add_payment",""],["change_notification_state",""],["get_blocks",""],["get_chain_prefix","Pop blocks off the start of the vector `blocks` as long as the total size of the blocks is less than `max_size`. FIXME: need to decide what to do if the first block is greater than max_size."],["iter_blocks",""],["print",""],["recover_from_failed_archive",""],["split_off_front","Similar to Vec::split_off. Splits the Vec into two at the given index. `vec` contains elements [at, len), and the returned Vec contains elements [0, at)."]],"mod":[["account_identifier",""],["archive",""],["http_request",""],["icpts",""],["metrics_encoder",""],["protobuf",""],["spawn",""],["timestamp",""],["validate_endpoints",""]],"struct":[["AccountBalanceArgs","Argument taken by the account_balance endpoint"],["Balances","Describes the state of users accounts at the tip of the chain"],["Block","A transaction with the metadata the canister generated attached to it"],["BlockArg",""],["BlockRes",""],["Blockchain","Stores a chain of transactions with their metadata"],["EncodedBlock",""],["GetBlocksArgs",""],["GetBlocksRes",""],["HashOf",""],["IterBlocksArgs",""],["IterBlocksRes",""],["LEDGER",""],["Ledger",""],["LedgerCanisterInitPayload",""],["MAX_MESSAGE_SIZE_BYTES",""],["Memo",""],["NotifyCanisterArgs","Argument taken by the notification endpoint"],["SendArgs","Argument taken by the send endpoint"],["TipOfChainRes","Argument returned by the tip_of_chain endpoint"],["TotalSupplyArgs","Argument taken by the total_supply endpoint"],["Transaction","A transfer with the metadata the client generated attached to it"],["TransactionNotification","Struct sent by the ledger canister when it notifies a recipient of a payment"]],"trait":[["BalancesStore",""]],"type":[["BlockHeight","Position of a block in the chain. The first block has position 0."],["Certification",""],["LedgerBalances",""]]});